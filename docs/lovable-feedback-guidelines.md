# üìã Remarques Critiques de Lovable.dev - Guidelines

> **Date de cr√©ation :** Janvier 2025  
> **Source :** Rapport d'analyse Lovable.dev sur le module de r√©conciliation  
> **Objectif :** √âviter de r√©p√©ter les m√™mes erreurs dans les futures impl√©mentations

---

## üö® **ERREURS CRITIQUES √Ä √âVITER ABSOLUMENT**

### **4. FAILLE DE S√âCURIT√â MAJEURE : Fonctions RPC mal s√©curis√©es**

**‚ùå ERREUR CRITIQUE :**
```sql
-- DANGEREUX : Accepte tenant_id depuis le client
CREATE OR REPLACE FUNCTION public.generate_sales_suggestions(p_tenant_id UUID)
```

**üî¥ RISQUES :**
- Utilisateur malveillant peut passer n'importe quel tenant_id
- Acc√®s aux donn√©es d'autres pharmacies
- Pas de `SECURITY DEFINER` = probl√®mes de permissions
- Aucune validation des droits d'acc√®s

**‚úÖ SOLUTION S√âCURIS√âE :**
```sql
-- Fonction s√©curis√©e qui r√©cup√®re automatiquement le tenant
CREATE OR REPLACE FUNCTION public.generate_sales_suggestions()
RETURNS TABLE(...)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    current_tenant_id UUID;
BEGIN
    -- R√©cup√©rer le tenant de l'utilisateur authentifi√©
    SELECT get_current_user_tenant_id() INTO current_tenant_id;
    
    IF current_tenant_id IS NULL THEN
        RAISE EXCEPTION 'Utilisateur non authentifi√© ou tenant non trouv√©';
    END IF;
    
    -- Utiliser current_tenant_id dans la logique
    RETURN QUERY
    SELECT ... FROM suggestions_vente 
    WHERE tenant_id = current_tenant_id;
END;
$$;
```

**üìù R√àGLE :** JAMAIS de tenant_id en param√®tre. Toujours r√©cup√©rer via `get_current_user_tenant_id()`.

---

### **5. POLITIQUES RLS INCORRECTES**

**‚ùå ERREUR COMMUNE :**
```sql
-- Ne fonctionne PAS dans ce projet
CREATE POLICY "Users can view their tenant suggestions" ON public.suggestions_vente
FOR SELECT USING (tenant_id = auth.jwt() ->> 'tenant_id'::text);
```

**üî¥ PROBL√àME :** 
- `auth.jwt() ->> 'tenant_id'` ne retourne rien dans ce projet
- Bloque TOUS les acc√®s aux donn√©es
- Utilise un pattern d'authentification incorrect

**‚úÖ SOLUTION CORRECTE :**
```sql
-- Pattern RLS correct pour ce projet
CREATE POLICY "Users can view their tenant suggestions" ON public.suggestions_vente
FOR SELECT USING (tenant_id = get_current_user_tenant_id());

-- Ou pour plus de s√©curit√©
CREATE POLICY "Users can view their tenant suggestions" ON public.suggestions_vente
FOR SELECT USING (
    tenant_id IN (
        SELECT p.tenant_id 
        FROM personnel p 
        WHERE p.auth_user_id = auth.uid()
    )
);
```

**üìù R√àGLE :** Toujours utiliser `get_current_user_tenant_id()` ou la table `personnel` pour les RLS.

---

### **6. SCH√âMA TYPESCRIPT NON SYNCHRONIS√â**

**‚ùå PROBL√àME FR√âQUENT :**
- Table existe en DB mais pas dans `database.types.ts`
- Cause des erreurs de build TypeScript
- Hooks frontend cass√©s

**‚úÖ SOLUTION :**
```bash
# R√©g√©n√©rer le sch√©ma TypeScript
supabase gen types typescript --project-id YOUR_PROJECT_ID > src/lib/database.types.ts
```

**üìù R√àGLE :** Toujours r√©g√©n√©rer les types apr√®s modification de sch√©ma DB.

---

### **1. CONTRAINTE CHECK sur le champ `type`**

**‚ùå ERREUR COMMUNE :**
```typescript
type: 'reconciliation',  // INVALIDE - Cause erreur 23514
```

**‚úÖ SOLUTION :**
```typescript
type: 'complet',  // Valeurs accept√©es : 'complet', 'partiel', 'cyclique'
```

**üìù R√àGLE :** Toujours v√©rifier les contraintes CHECK en base avant d'ins√©rer des donn√©es.

---

### **2. FAILLE DE S√âCURIT√â : UUID hardcod√©**

**‚ùå ERREUR CRITIQUE :**
```typescript
agent_id: '00000000-0000-0000-0000-000000000000'  // DANGEREUX
```

**‚úÖ SOLUTION S√âCURIS√âE :**
```typescript
// Option 1 : Utiliser l'utilisateur authentifi√©
agent_id: auth.uid()

// Option 2 : R√©cup√©rer le personnel associ√©
const { data: personnel } = await supabase
  .from('personnel')
  .select('id')
  .eq('auth_user_id', auth.uid())
  .single();
agent_id: personnel?.id
```

**üìù R√àGLE :** JAMAIS d'UUID hardcod√©. Toujours utiliser l'authentification r√©elle.

---

### **3. DONN√âES MOCK√âES vs DONN√âES R√âELLES**

**‚ùå PROBL√àME FR√âQUENT :**
- Composants utilisant uniquement des donn√©es mock√©es
- Boutons de validation qui ne font rien
- Aucune persistance en base de donn√©es

**‚úÖ BONNES PRATIQUES :**
- Toujours connecter les composants √† Supabase
- Impl√©menter la persistance des donn√©es
- Tester les actions utilisateur avec de vraies donn√©es

---

## üîê **S√âCURIT√â RLS - Points d'Attention**

### **Probl√®mes identifi√©s par Lovable :**
- Policies RLS trop permissives
- Acc√®s anonyme autoris√© sur certaines tables
- Syst√®me d'authentification des pharmacies bloqu√©

### **V√©rifications obligatoires :**
1. **Avant chaque requ√™te Supabase :**
   - V√©rifier que l'utilisateur est authentifi√©
   - S'assurer que le `tenant_id` est correct
   - Valider les permissions RLS

2. **Pour les insertions :**
   - Utiliser des IDs r√©els (pas de hardcoding)
   - Respecter les contraintes de cl√© √©trang√®re
   - Valider les formats de donn√©es

---

## üìä **STRUCTURE DE DONN√âES - Bonnes Pratiques**

### **Formats de dates :**
```typescript
// ‚ùå √âviter
date_debut: currentSession.date,

// ‚úÖ Recommand√©
date_debut: new Date(currentSession.date).toISOString(),
```

### **Noms et responsables :**
```typescript
// ‚ùå √âviter
responsable: 'Utilisateur actuel',

// ‚úÖ Recommand√©
responsable: `${currentPersonnel?.prenoms} ${currentPersonnel?.noms}`,
```

---

## üîß **HOOKS ET INT√âGRATIONS**

### **Pattern recommand√© pour les hooks Supabase :**

```typescript
export const useInventoryReconciliation = (sessionId?: string) => {
  const { tenantId } = useTenant();
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);

  const fetchReconciliationData = async () => {
    try {
      setLoading(true);
      
      // ‚úÖ Requ√™te r√©elle avec relations
      const { data, error } = await supabase
        .from('inventaire_lignes')
        .select(`
          *,
          produits (libelle_produit),
          lots (numero_lot, quantite_restante)
        `)
        .eq('tenant_id', tenantId)
        .eq('session_id', sessionId);

      if (error) throw error;
      setItems(data || []);
    } catch (error) {
      console.error('Erreur:', error);
      toast.error('Erreur lors du chargement');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (sessionId && tenantId) {
      fetchReconciliationData();
    }
  }, [sessionId, tenantId]);

  return { items, loading, refetch: fetchReconciliationData };
};
```

---

### 8. **‚ùå ERREUR CRITIQUE : Conflit de Surcharge de Fonction PostgreSQL (PGRST203)**

**Probl√®me** : L'erreur `PGRST203` indique un conflit de surcharge de fonction (`function overloading`) dans PostgreSQL. Cela se produit lorsque plusieurs versions d'une m√™me fonction (ex: `rpc_stock_record_movement`) existent dans la base de donn√©es avec des signatures de param√®tres incompatibles. PostgreSQL ne peut pas d√©terminer quelle version utiliser, m√™me si le code client appelle une version sp√©cifique.

**Exemple Concret** :
- **Version 1 (Utilis√©e par le code TypeScript)** :
  ```sql
  CREATE OR REPLACE FUNCTION rpc_stock_record_movement(
      p_lot_id UUID,
      p_produit_id UUID,
      p_type_mouvement TEXT,
      p_quantite_mouvement INTEGER,
      p_motif TEXT DEFAULT NULL,
      p_quantite_reelle INTEGER DEFAULT NULL
  )
  ```
- **Version 2 (Conflictuelle)** :
  ```sql
  CREATE OR REPLACE FUNCTION rpc_stock_record_movement(
      p_type_mouvement text,
      p_produit_id uuid,
      p_quantite_mouvement integer,
      p_lot_id uuid DEFAULT NULL
  )
  ```
Le code TypeScript appelait la Version 1, mais la pr√©sence de la Version 2 cr√©ait une ambigu√Øt√© pour PostgreSQL.

**Solution** :
1.  **Identifier les versions conflictuelles** : Examiner les migrations et le sch√©ma de la base de donn√©es pour trouver toutes les d√©finitions de la fonction en question.
2.  **Supprimer toutes les versions conflictuelles** : Cr√©er une migration SQL qui supprime explicitement toutes les versions de la fonction.
    ```sql
    DROP FUNCTION IF EXISTS rpc_stock_record_movement(UUID, UUID, TEXT, INTEGER, TEXT, INTEGER);
    DROP FUNCTION IF EXISTS rpc_stock_record_movement(TEXT, UUID, INTEGER, UUID);
    -- Ajouter toutes les signatures existantes √† supprimer
    ```
3.  **Recr√©er la fonction correcte** : Apr√®s avoir supprim√© toutes les versions, recr√©er la fonction avec la signature et la logique d√©sir√©es.

**R√®gle d'Or** : Avant de cr√©er ou de modifier une fonction PostgreSQL, toujours v√©rifier s'il existe des versions ant√©rieures avec des signatures similaires. En cas de doute, supprimer explicitement toutes les versions possibles avant de recr√©er la fonction pour √©viter les ambigu√Øt√©s.

### 9. **üìù CHECKLIST D'IMPL√âMENTATION**

### **Avant de coder :**
- [ ] V√©rifier les contraintes de base de donn√©es
- [ ] Identifier les cl√©s √©trang√®res requises
- [ ] Planifier l'authentification et les permissions
- [ ] D√©finir les formats de donn√©es attendus
- [ ] **S'assurer que les fonctions RPC sont s√©curis√©es (pas de tenant_id en param√®tre)**
- [ ] **V√©rifier que les politiques RLS utilisent `get_current_user_tenant_id()`**

### **Pendant le d√©veloppement :**
- [ ] Utiliser des donn√©es r√©elles (pas de mock)
- [ ] Impl√©menter la gestion d'erreurs
- [ ] Tester avec diff√©rents utilisateurs/tenants
- [ ] Valider les contraintes RLS
- [ ] **Tester l'isolation des tenants (s√©curit√© multi-tenant)**
- [ ] **V√©rifier que les fonctions RPC ont `SECURITY DEFINER`**

### **Avant le commit :**
- [ ] Tester toutes les actions utilisateur
- [ ] V√©rifier les logs d'erreur
- [ ] S'assurer que les donn√©es sont persist√©es
- [ ] Valider la s√©curit√© des requ√™tes
- [ ] **R√©g√©n√©rer les types TypeScript si sch√©ma DB modifi√©**
- [ ] **Tester l'acc√®s cross-tenant (doit √™tre bloqu√©)**

---

## üéØ **R√àGLES D'OR**

1. **S√âCURIT√â FIRST** : Jamais d'UUID hardcod√©, toujours authentifier
2. **DONN√âES R√âELLES** : Connecter tous les composants √† Supabase
3. **CONTRAINTES DB** : V√©rifier les contraintes avant d'ins√©rer
4. **GESTION D'ERREURS** : Toujours impl√©menter try/catch et feedback utilisateur
5. **TENANT ISOLATION** : Toujours filtrer par tenant_id
6. **AUDIT TRAIL** : Tracer toutes les actions avec les vrais utilisateurs
7. **üîê FONCTIONS RPC S√âCURIS√âES** : Jamais de tenant_id en param√®tre, toujours `SECURITY DEFINER`
8. **üõ°Ô∏è RLS CORRECT** : Utiliser `get_current_user_tenant_id()` pas `auth.jwt()`
9. **üìä TYPES SYNCHRONIS√âS** : R√©g√©n√©rer les types apr√®s chaque modification de sch√©ma

---

## üîë **ACC√àS SUPABASE CLOUD**

**IMPORTANT :** L'assistant a acc√®s aux cl√©s Supabase Cloud via le fichier `.env` et peut :
- G√©n√©rer les types TypeScript directement depuis Supabase Cloud
- Ex√©cuter des requ√™tes et tester les fonctions RPC
- V√©rifier la structure des tables et sch√©mas
- Cr√©er ou modifier des fonctions SQL

**Commande pour g√©n√©rer les types :**
```bash
npx supabase gen types typescript --project-id PROJECT_ID > src/lib/database.types.ts
```

---

## üìö **RESSOURCES UTILES**

- **Contraintes DB :** Consulter `database.types.ts` pour les types
- **RLS Policies :** V√©rifier dans les migrations Supabase
- **Authentification :** Utiliser `useAuth()` et `useTenant()`
- **Gestion d'erreurs :** Pattern avec toast.error() pour le feedback

---

## üìö **LOGIQUE EN CASCADE**
- Le syst√®me utilise maintenant pour les alertes de stock 
- 1) valeurs produit (stock_limite, stock_alert et stock critique) ‚Üí 2) param√®tres utilisateur (alert_settings) ‚Üí 3) valeurs par d√©faut.

> **üí° RAPPEL :** Ce document doit √™tre consult√© avant chaque impl√©mentation majeure pour √©viter de r√©p√©ter les erreurs identifi√©es par Lovable.dev.